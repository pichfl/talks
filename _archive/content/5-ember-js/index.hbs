---
title: An ambitious introduction to Ember.js
author: Florian Pichler
style: |
  section:first-child,
  section:nth-child(3) {
    background-image: url(emberjs.svg);
    background-repeat: no-repeat;
    background-position: center;
  }
  section:nth-child(2) img {
    margin-top: calc(50vh - 285px);
  }
  h1 {
    margin-bottom: 2.5em;
  }
---
{{> top}}

{{#slides}}

==== #intro .title


<h1>An ambitious introduction to <span class="aux">Ember.js</span></h1>
<p><em>By {{author}}</em></p>

<footer><a href="../">More talks by @pichfl</a></footer>

==== #tomster


![tomster](./original.png)


==== #intro2 .title


<h1>Ein ambitionierter Einstieg in <span class="aux">Ember.js</span></h1>
<p><em>Von {{author}}</em></p>

<footer><a href="../">Mehr Vorträge</a></footer>


==== #history

## Geschichte

- Ember.js ist ein Fork von SproutCore, berüchtigt für Apples MobileMe
- Von Yehuda Katz (core team member of jQuery, Ruby on Rails, …) und vielen anderen
- MVC-Framework für "single-page web applications"



==== #ambitious

## “A framework for creating ambitious web applications”

- Open-source. Entwicklung wird durch RFCs beeinflusst
- Einsatz von [Semantic Versioning](http://semver.org)
- Konvention vor Konfiguration (wie auch bei Rails)
- Stark und trotzdem flexibel durch Einhaltung von Konzepten der Core-Entwickler
- Viele Sponsoren statt einer Firma als Owner: Yahoo, LinkedIn, Bustle, Yapp, Tilde, Square
- Prominente Nutzer: Discourse, Groupon, Vine, Nordstrom, Twitch.tv, Apple Music, Sony PSN, …



==== #features

## Meta Features

- ES2015 modules (via Babel.js)
- Ember-CLI
- Ember Inspector
- Release-Zyklus von 6 Wochen, mit Beta-Releases und canary channel
- LTS Support
- Freundliche und hilfsbereite Community



==== #basics

## Basic concepts

- Ember Objects
- Routes
- Services
- Templates
- Components
- (Controllers)
- Models (Ember Data)

==== #ember-objects

## Ember.Object

- (noch) Alternative zu ES2015 Klassen, etc.
- Unterstützung für die Überwachung von Änderungen an Eigenschaften von Objekten*
- Klassen-System mit Mixins, Extending, Constructors
- Ember.Enumerable liefert Arrays mit KVO-Support


<br>\* auch bekannt als Key Value Observer / KVO. `Object.oberserve()` sollte ein ähnliches Verhalten liefern, ist aber obsolet. Zukünftig könnte Ember auf `Proxy` setzen.


==== #classes-instances

## Klassen, Instanzen, Reopening

- Neue Klassen durch `.extend({})` von `Ember.Object`
- Neue Instanzen durch `.create({})` einer Klasse.
- Sowohl Instanzen als auch deren Basis-Klasse lassen sich durch `.reopen()` bzw. `.reopenClass` zur Laufzeit verändern, falls nötig. Dieses Verhalten erlaubt es Addons zum Start der Ember-App Verhalten nachzurüsten, z.B. Event Handler oder Computed Properties.


==== #computed

## Computed Properties

- Makros mit automatischem Caching für Ergebnisse
- Cache-Invalidation erfolgt automatisch durch Angabe von Abhängigkeiten
- Durch das Cache nur unwesentlich langsamer als statische Eigenschaften
- Unterstützung für Getter/Setter (Getter als Default)

```js
Ember.Object.extend({
	firstName: 'Jon',
	lastName: 'Snow',

	fullName: computed('firstName', 'lastName', function() {
		const firstName = this.get('firstName');
		const lastName = this.get('lastName');

		return `${firstName} ${lastName}`;
	}),
});
```


==== #computed-macros

## Computed.Macros

```js
computed.and('A', 'B') // A && B
computed.filterBy('C', 'key', true) // _.filter(C, 'key', true)
computed.not('D') // === !propD
computed.mapBy('E', 'key') // Object.keys(E)
```

- 30+ Makros mitgeliefert
- eigene Makros sind leicht zu erstellen
- Nützlich um Logik aus Templates zu halten
- Cached Two-Way- und One-Way-Bindings

```js
computed.alias('serviceName.foo')
computed.oneWay('other.path') // reads until overwritten
computed.readOnly('foo.bar') // throws if trying to write
```



==== #routing-router

## The router

- App-Zustand dargestellt durch die URL
- extrem zuverlässig - u.A. Inspiration für den ui-router für Angular.js
- dynamische URL-Segemente, Query-Parameter und Schachtelung
- Autogenerated routes


```js
Router.map(function() {
	this.route('entries', function() {
		// this.route('index', {path: '/'}); //autogenerated
		this.route('new'); // entries/new
		this.route(':entry'); // entries/1
	});
});
```



==== #routing-routes

## Routes

- Daten laden
- Verstehen und nutzen Promises für Ladezustände und Fehlerbehandlung
- Template (Component) Setup
- Verarbeitung von Actions


```js
export default Ember.Route.extend({
	model() {
		// using ember-data
		return this.store.findAll('entry');

		// return jQuery.ajax(…); // works as well
	},

	afterModel(model) {
		if (!model) {
			this.redirect('entries.new');
		}
	},
});
```



==== #services

## Services

- Langlebige Ember-Objekte, die an vielen Stellen einer App genutzt werden können
- Beispiele
	- Timer (globaler Tick)
	- Lieferant für UI-Übersetzungen
	- Kommunikation mit Scripts außerhalb von Ember.js

```js
export default Controller.extend({
	ticktock: Ember.inject.service(),

	now: computed('ticktock.pulse', function() {
		return new Date();
	}),
});
```



==== #templates

## Templates

- <del>Handlebars</del> <del>HTMLBars</del> <ins>Glimmer</ins>
	+ Über die Jahre wurde die Engine mehrfach getauscht, ohne Mehrarbeit für Nutzer von Ember
- Vorkompilierte Templates ohne Logik, als eigenständige Dateien oder in einer Component
- Glimmer nutzt ein ähnliches Konzept wie React (Virtual DOM)
	+ Unterscheidung nicht auf DOM-Ebene, sondern in den Daten
- Glimmer 2: In Typescript geschrieben. „Run-Time-Compiler für HTML“ - Noch schneller und ohne API-Changes für Nutzer



==== #components

## Components

- Kombination aus Template und Source Code
- Orientieren sich an Web Components
- Unterstützung für Angle-Brackets `<a-component />` mit Glimmer 2, aktueller Syntax an Handlebars orientiert
- Data down, actions up als aktuelle Empfehlung.
- Live-Cycle-Hooks zur effizienten Nutzung (Setup, Re-Rendering, etc.)
- Mit Release von Glimmer viele Analogien zu React



==== #controllers

## Controllers

- Historisch zuständig für die Manipulation von in einer Route geladenen Model-Daten
- Noch nicht deprecated, aber Plan besteht, dies mit Ember 3.0 in die Tat umzusetzen und sie nahtlos durch Routable Components zu ersetzen
- Aktuell als Sonderfall einer Component beschrieben
- Wird automatisch zur Laufzeit für jede Route generiert, falls nicht vorhanden
- Jede Route hat aktuell einen Controller mit `model` Eigenschaft
- Reagiert auf Actions im Template


==== #ember-data

## Ember Data

- Kein fester, aber empfohlener Bestandteil von Ember
- Abstrahiert die Kommunikation mit JSONAPI-/REST-basierten APIs
- Persistance Layer inkl. Rollback und Caching
- Andere Formate durch Adapter und Serializer relativ leicht umzusetzen
- Adapter und Serializer für jedes Model einzeln anpassbar
- Stream- und Promise-basiert



==== #models

## Models

- Beschreiben Struktur der Inhalte eines API-Endpunkts


```js
export default DS.Model.extend({
	name: attr('string'),
	age: attr('number'),
	parents: hasMany('person', {
		async: true,
	})
});
```



==== #ember-inspector

## Ember Inspector

Ein Browser-Addon für Chrome und Firefox sowie ein Bookmarklet für alle anderen Brower.

- Schneller Überblick über aktive Routes, Views, Components
- Promise-Debugger für alle in Ember genutzten Promises
- Daten-Ansicht für sämtliche Datensätze und deren Zustände im Store von Ember Data
- Gesammelte Deprecation Nachrichten
- Render Performance Informationen



==== #ember-cli

## Ember CLI

Webpack, Grunt, Gulp, Composer & Co? Nicht nötig.

- Developement Server mit Live-Reload
- Generatoren & Blueprints für sämtliche Bestandteile von Ember
- Update-Management
- Production Builds inkl. Optimierung
- Addon-System
- Testing



==== #addons

## Addons

- Funktionen für eine App (Components, sogar ganze Apps)
- Funktionen für den Build-Prozess (SASS, ESLint, zusätzliche Blueprints)

### Beliebte Addons
+ Ember Simple Auth: Abstrahiert Authentifizierung, inkl. Login
+ ember-i18n: Lokalisierung
+ cp-validations: Lazy Validierung von Models und beliebigen Objekten



==== #why-ember

## Warum Ember?

+ auch nach mittlerweile vier Jahren immer zuverlässig
+ Testing und Langlebigkeit von Projekten
+ Klare Sturukturen auch für große Projekte
+ Mittlerweile relativ einfacher Einstieg
+ Hilfsbereite Community
+ Projekte wie Glimmer zeigen, dass Fortschritt möglich ist, ohne immer wieder von Vorn anfangen zu müssen.



==== #questions .title

# Fragen?

Gerne jetzt, oder jederzeit auf den üblichen Kanälen.



==== #thanks .title


# Danke fürs Zuhören

Florian Pichler / @pichfl / fp@ylk.gd



{{/slides}}

{{> end}}